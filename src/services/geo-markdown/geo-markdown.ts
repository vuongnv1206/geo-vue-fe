// {
//     content: 'Who formulated the theory of relativity?',
//     image: null,
//     audio: null,
//     questionFolder: {
//       name: 'Science',
//       parentId: null,
//     },
//     questionType: 2,
//     questionLable: {
//       id: 'e2bc24e8-51b9-4fa6-bacc-88cb58c9e1d1',
//       name: 'Scientist',
//       color: 'Primary',
//     },
//     questionPassages: [],
//     answers: [
//       {
//         id: '2dd12924-a608-421c-a17b-72bb1810811f',
//         content: 'Isaac Newton',
//         questionId: 'd1cb3693-621e-45b6-8f9e-7c86e46e1403',
//         isCorrect: false,
//       },
//       {
//         id: '407bb5e0-5006-445f-a78d-1c29fb418f36',
//         content: 'Max Planck',
//         questionId: 'd1cb3693-621e-45b6-8f9e-7c86e46e1403',
//         isCorrect: true,
//       },
//       {
//         id: '832ca96c-94c7-4bb8-bc5a-6bd062b20539',
//         content: 'Albert Einstein',
//         questionId: 'd1cb3693-621e-45b6-8f9e-7c86e46e1403',
//         isCorrect: true,
//       },
//       {
//         id: 'd4c6cd04-f1e9-4e6d-bd7a-fd7ef4c1c93e',
//         content: 'Niels Bohr',
//         questionId: 'd1cb3693-621e-45b6-8f9e-7c86e46e1403',
//         isCorrect: false,
//       },
//     ],
//     createdBy: '00000000-0000-0000-0000-000000000000',
//     createdOn: '2024-06-01T15:34:11.979465+07:00',
//     lastModifiedBy: '00000000-0000-0000-0000-000000000000',
//     lastModifiedOn: '2024-06-01T15:34:11.979465+07:00',
//     deletedOn: null,
//     deletedBy: null,
//     id: 'd1cb3693-621e-45b6-8f9e-7c86e46e1403',
//   },
//   {
//     "content": "The $_fillblank[1] Ocean is the largest ocean on Earth, covering about $_fillblank[2] of the Earth's surface.",
//     "image": null,
//     "audio": null,
//     "questionFolder": {
//       "name": "Geography",
//       "parentId": null
//     },
//     "questionType": 4,
//     "questionLable": {
//       "id": "1c751000-6a24-4b6b-a547-f69df554e1e4",
//       "name": "Geography Facts",
//       "color": "Primary"
//     },
//     "questionPassages": [],
//     "answers": [
//       {
//         "id": "41f595dc-4262-42f3-833b-214b4cda1bc8",
//         "content": "$_[2]30%",
//         "questionId": "0e20082e-301e-4514-922f-4bdba702bcb8",
//         "isCorrect": true
//       },
//       {
//         "id": "ae6a72dc-ab6a-4cfc-beac-f6fb23f61864",
//         "content": "$_[1]Pacific",
//         "questionId": "0e20082e-301e-4514-922f-4bdba702bcb8",
//         "isCorrect": true
//       }
//     ],
//     "createdBy": "00000000-0000-0000-0000-000000000000",
//     "createdOn": "2024-06-02T16:57:21.749333+07:00",
//     "lastModifiedBy": "00000000-0000-0000-0000-000000000000",
//     "lastModifiedOn": "2024-06-02T16:57:21.749333+07:00",
//     "deletedOn": null,
//     "deletedBy": null,
//     "id": "0e20082e-301e-4514-922f-4bdba702bcb8",
//   },
//   {
//     content:
//       '{ "Question": "Match the scientists with their discoveries:", "ColumnA": { "1": "Isaac Newton", "2": "Albert Einstein", "3": "Marie Curie", "4": "Charles Darwin" }, "ColumnB": { "1": "Theory of Evolution", "2": "Theory of Relativity", "3": "Law of Gravity", "4": "Radioactivity" } }',
//     image: null,
//     audio: null,
//     questionFolder: {
//       name: 'Science',
//       parentId: null,
//     },
//     questionType: 5,
//     questionLable: {
//       id: 'ff6115b0-c64d-45f4-a8bc-81390811a7d9',
//       name: 'Scientist-Discovery Matching',
//       color: 'Primary',
//     },
//     questionPassages: [],
//     answers: [
//       {
//         id: '11c0e62b-62b4-4064-8090-69bbad768278',
//         content: '1_3|2_2|3_4|4_1',
//         questionId: 'df777b2e-50fa-4905-8bc2-d66b47d38778',
//         isCorrect: true,
//       },
//     ],
//     createdBy: '00000000-0000-0000-0000-000000000000',
//     createdOn: '2024-06-01T15:34:11.980025+07:00',
//     lastModifiedBy: '00000000-0000-0000-0000-000000000000',
//     lastModifiedOn: '2024-06-01T15:34:11.980025+07:00',
//     deletedOn: null,
//     deletedBy: null,
//     id: 'df777b2e-50fa-4905-8bc2-d66b47d38778',
//   },
//   {
//     content:
//       'The Industrial Revolution was a period of major industrialization and innovation that occurred in the late 18th and early 19th centuries, starting in Great Britain and later spreading throughout the world. It marked a significant shift from agrarian and handicraft-based economies to ones dominated by industry and machine manufacturing. The key developments of the Industrial Revolution included the invention of the steam engine, the expansion of factories, and the mass production of goods. These changes led to urbanization as people moved from rural areas to cities in search of employment opportunities in factories. While the Industrial Revolution brought about many advancements and improvements in living standards for some, it also led to significant social and environmental challenges, including poor working conditions, pollution, and the widening gap between the rich and the poor.',
//     image: null,
//     audio: null,
//     questionFolder: {
//       name: 'Science',
//       parentId: null,
//     },
//     questionType: 6,
//     questionLable: {
//       id: 'e7043234-9650-4b8c-abee-2dc1ea7ecd56',
//       name: 'Reading Comprehension',
//       color: '#FF0000',
//     },
//     questionPassages: [
//       {
//         id: 'bbbabdb4-124e-4857-a3ee-eb1a118553f4',
//         content: 'What were some key developments of the Industrial Revolution?',
//         answers: [
//           {
//             id: '45786207-5a32-4f20-a66a-421e998b5c51',
//             content:
//               'Invention of the printing press, development of the scientific method, and discovery of penicillin.',
//             questionId: 'bbbabdb4-124e-4857-a3ee-eb1a118553f4',
//             isCorrect: false,
//           },
//           {
//             id: '559ad023-8495-4ecf-89da-088ca2cb0090',
//             content: 'Exploration of space, colonization of new lands, and establishment of trade routes.',
//             questionId: 'bbbabdb4-124e-4857-a3ee-eb1a118553f4',
//             isCorrect: false,
//           },
//           {
//             id: 'a5747274-9e56-4055-85d9-73338fdb0e5d',
//             content: 'Discovery of electricity, invention of the telephone, and development of the internet.',
//             questionId: 'bbbabdb4-124e-4857-a3ee-eb1a118553f4',
//             isCorrect: false,
//           },
//           {
//             id: 'ff737a30-b270-4a05-a7e6-e534ce889319',
//             content: 'Invention of the steam engine, expansion of factories, and mass production of goods.',
//             questionId: 'bbbabdb4-124e-4857-a3ee-eb1a118553f4',
//             isCorrect: true,
//           },
//         ],
//       },
//       {
//         id: 'f0835619-2161-4180-8dbf-2c89545c0a66',
//         content: 'What was the Industrial Revolution?',
//         answers: [
//           {
//             id: '6d3b8488-8aaf-444c-a000-5058be287b75',
//             content: 'A period of political revolution in Europe.',
//             questionId: 'f0835619-2161-4180-8dbf-2c89545c0a66',
//             isCorrect: false,
//           },
//           {
//             id: '97ef51e2-4531-4c55-90a7-2d275c9c9acf',
//             content: 'A period of artistic and cultural revival in Italy.',
//             questionId: 'f0835619-2161-4180-8dbf-2c89545c0a66',
//             isCorrect: false,
//           },
//           {
//             id: '9b2df5c6-94ed-4a35-b35a-b51108d82d13',
//             content: 'A period of religious reform in the Middle East.',
//             questionId: 'f0835619-2161-4180-8dbf-2c89545c0a66',
//             isCorrect: false,
//           },
//           {
//             id: 'c5520f10-0ec2-488f-8028-2dd34225fc8f',
//             content:
//               'A period of major industrialization and innovation that occurred in the late 18th and early 19th centuries.',
//             questionId: 'f0835619-2161-4180-8dbf-2c89545c0a66',
//             isCorrect: true,
//           },
//         ],
//       },
//     ],
//     answers: [],
//     createdBy: '00000000-0000-0000-0000-000000000000',
//     createdOn: '2024-06-01T15:34:11.980051+07:00',
//     lastModifiedBy: '00000000-0000-0000-0000-000000000000',
//     lastModifiedOn: '2024-06-01T15:34:11.980052+07:00',
//     deletedOn: null,
//     deletedBy: null,
//     id: '1ca69809-9bad-40c6-af91-068b542696db',
//   },
//   {
//     content: 'Test add',
//     image: '/disk/test.png',
//     audio: '',
//     questionFolder: {
//       name: 'Science',
//       parentId: null,
//     },
//     questionType: 1,
//     questionLable: null,
//     questionPassages: [],
//     answers: [
//       {
//         id: '3b478d94-20d9-43c2-b274-4fcda9b03cb9',
//         content: 'answer 2',
//         questionId: 'aea88efd-2f2d-402c-bf7e-10bebe8b4a31',
//         isCorrect: false,
//       },
//       {
//         id: 'f9ffb027-712a-4f04-aad9-334b0870fc44',
//         content: 'answer 1',
//         questionId: 'aea88efd-2f2d-402c-bf7e-10bebe8b4a31',
//         isCorrect: true,
//       },
//     ],
//     createdBy: 'ab592601-d719-4f96-a0b8-0fba5e4c1c12',
//     createdOn: '2024-06-01T19:11:21.308363+07:00',
//     lastModifiedBy: 'ab592601-d719-4f96-a0b8-0fba5e4c1c12',
//     lastModifiedOn: '2024-06-01T19:11:21.308363+07:00',
//     deletedOn: null,
//     deletedBy: null,
//     id: 'aea88efd-2f2d-402c-bf7e-10bebe8b4a31',
//   },
//   {
//     "content": "Write a short essay on the importance of education in society.",
//     "image": null,
//     "audio": null,
//     "questionFolder": {
//       "name": "Education",
//       "parentId": null
//     },
//     "questionType": 8,
//     "questionLable": {
//       "id": "54b11199-e390-4024-999d-672418619043",
//       "name": "Essay",
//       "color": "Primary"
//     },
//     "questionPassages": [],
//     "answers": [],
//     "createdBy": "00000000-0000-0000-0000-000000000000",
//     "createdOn": "2024-06-02T16:57:21.749744+07:00",
//     "lastModifiedBy": "00000000-0000-0000-0000-000000000000",
//     "lastModifiedOn": "2024-06-02T16:57:21.749744+07:00",
//     "deletedOn": null,
//     "deletedBy": null,
//     "id": "2283e817-c513-4b44-8558-32b31e96485e",
//   },

import { Answer, Question, QuestionType } from '@/pages/question/types'

const multipleChoiceMarkdown = (question: Question, index: number) => {
  const answers = question.answers
    .map((answer, index) => {
      const isCorrect = answer.isCorrect ? '*' : ''
      return `${isCorrect}${String.fromCharCode(65 + index)}. ${answer.content}`
    })
    .join('\n')
  return `Q${index + 1}. ${question.content}\n${answers}`
}

const singleChoiceMarkdown = (question: Question, index: number) => {
  const answers = question.answers
    .map((answer, index) => {
      const isCorrect = answer.isCorrect ? '*' : ''
      return `${isCorrect}${String.fromCharCode(65 + index)}. ${answer.content}`
    })
    .join('\n')
  const res = `Q${index + 1}. ${question.content}\n${answers}`
  return res
}

const fillBlankMarkdown = (question: Question, index: number) => {
  const content = question.content.replace(/\$_fillblank/g, '$').trim()
  let answersStr = ''
  const answers: Record<number, Answer> = {}
  question.answers.forEach((answer) => {
    const regex = /\$_\[(\d+)\]/
    const match = answer.content.match(regex)
    if (match) {
      const index = parseInt(match[1])
      answers[index] = answer
    }
  })
  for (let i = 1; i <= Object.keys(answers).length; i++) {
    const content = answers[i].content.replace(/\$_\[\d+\]/, '').trim()
    answersStr += `${i}. ${content}\n`
  }
  answersStr = answersStr
    .split('\n')
    .map((line) => line.trim())
    .join('\n')

  const res = `Q${index + 1}. ${content}\n${answersStr}`
  return res
}

const matchingMarkdown = (question: Question, index: number) => {
  const content = JSON.parse(question.content)

  const columnA = Object.entries(content.ColumnA)
    .map(([key, value]) => `${key}. ${value}`)
    .join('\n')

  const columnB = Object.entries(content.ColumnB)
    .map(([key, value]) => `${key}. ${value}`)
    .join('\n')

  const correctMatches = question.answers
    .filter((answer) => answer.isCorrect)
    .map((answer) => answer.content)
    .join('|')

  const a = `Q${index + 1}. ${content.Question}\nCL1:\n${columnA}\n\nCL2:\n${columnB}\n\nCorrect Matches: ${correctMatches}`
  return a
}

const readingMarkdown = (question: Question, index: number) => {
  const passage = `Q${index + 1}. ${question.content}`
  const questions = question.questionPassages
    ?.map((passageQuestion, passageIndex) => {
      const answers = passageQuestion.answers
        .map((answer, answerIndex) => {
          const isCorrect = answer.isCorrect ? '*' : ''
          return `${isCorrect}${String.fromCharCode(65 + answerIndex)}. ${answer.content}`
        })
        .join('\n')
      return `Q${index + 1}.${passageIndex + 1}. ${passageQuestion.content}\n${answers}`
    })
    .join('\n\n')
  return `${passage}\n\n${questions}`
}

const writingMarkdown = (question: Question, index: number) => {
  return `Q${index + 1}. ${question.content}`
}

export const toGeoMarkdown = (question: Question, index: number) => {
  if (question.questionType === QuestionType.MultipleChoice) {
    return multipleChoiceMarkdown(question, index)
  }
  if (question.questionType === QuestionType.SingleChoice) {
    return singleChoiceMarkdown(question, index)
  }
  if (question.questionType === QuestionType.FillBlank) {
    return fillBlankMarkdown(question, index)
  }
  if (question.questionType === QuestionType.Matching) {
    return matchingMarkdown(question, index)
  }
  if (question.questionType === QuestionType.Reading) {
    return readingMarkdown(question, index)
  }
  if (question.questionType === QuestionType.Writing) {
    return writingMarkdown(question, index)
  }

  return ''
}

export const replaceMultipleNewLines = (text: string) => {
  // only one new line is allowed
  return text.replace(/\n{2,}/g, '\n')
}

export const multipleChoiceText2Html = (text: string) => {
  const questionRegex = /Q(\d+)\.(.*?\n(?:.*\n)*?)(?=A\.|\*A\.)/
  const answerRegex = /(\*?)([A-Z])\.\s(.+)/g
  const questionMatch = text.match(questionRegex)
  if (!questionMatch) {
    return ''
  }
  let question = questionMatch[2].trim()
  question = question
    .split('\n')
    .map((item, index) => {
      if (index === 0)
        return `<p><strong style="color:blue;font-weight: bold;">Q${questionMatch[1]}.</strong> ${item}</p>`
      else return `<p>${item}</p>`
    })
    .join('')

  const answers = []
  let answerMatch
  while ((answerMatch = answerRegex.exec(text)) !== null) {
    const answer = `<p><strong style="color:#ff0000;font-weight: bold;">${answerMatch[1] ? '*' : ''}${answerMatch[2]}.</strong> ${answerMatch[3]}</p>`
    answers.push(answer)
  }
  const res = `${question}${answers.join('')}`
  return res
}

export const singleChoiceText2Html = (text: string) => {
  const questionRegex = /Q(\d+)\.(.*?\n(?:.*\n)*?)(?=A\.|\*A\.)/
  const answerRegex = /(\*?)([A-Z])\.\s(.+)/g
  const questionMatch = text.match(questionRegex)
  if (!questionMatch) {
    return ''
  }
  let question = questionMatch[2].trim()
  question = question
    .split('\n')
    .map((item, index) => {
      if (index === 0)
        return `<p><strong style="color:blue;font-weight: bold;">Q${questionMatch[1]}.</strong> ${item}</p>`
      else return `<p>${item}</p>`
    })
    .join('')
  const answers = []
  let answerMatch
  while ((answerMatch = answerRegex.exec(text)) !== null) {
    const answer = `<p><strong style="color:#ff0000;font-weight: bold;">${answerMatch[1] ? '*' : ''}${answerMatch[2]}.</strong> ${answerMatch[3]}</p>`
    answers.push(answer)
  }
  const res = `${question}${answers.join('')}`
  return res
}

export const fillBlankText2Html = (text: string) => {
  const questionRegex = /Q(\d+)\.(.*?\n(?:.*\n)*?)(?=\d\..*\n)/
  const answerRegex = /(\d+)\.\s(.+)/g
  const questionMatch = text.match(questionRegex)
  text = text.replace(questionRegex, '')
  if (!questionMatch) {
    return ''
  }
  let question = questionMatch[2]
  question = question.replace(/(\$\[\d+\])/g, '<span style="color:#ab2428;">$1</span>')
  question = question.trim()
  question = question
    .split('\n')
    .map((item, index) => {
      if (index === 0)
        return `<p><strong style="color:blue;font-weight: bold;">Q${questionMatch[1]}.</strong> ${item}</p>`
      else return `<p>${item}</p>`
    })
    .join('')
  const answers = []
  let answerMatch
  while ((answerMatch = answerRegex.exec(text)) !== null) {
    const answer = `<p><strong style="color:#ff0000;font-weight: bold;">${answerMatch[1]}.</strong> ${answerMatch[2]}</p>`
    answers.push(answer)
  }
  return `${question}${answers.join('')}`
}

export const matchingText2Html = (text: string) => {
  // Extract question part from text
  const questionRegex = /Q(\d+)\.\s*(.*?)(?=CL1:)/s
  const questionMatch = text.match(questionRegex)
  const question = questionMatch
    ? questionMatch[2]
        .trim()
        .split('\n')
        .map((item, index) => {
          if (index === 0)
            return `<p><strong style="color:blue;font-weight: bold;">Q${questionMatch[1]}.</strong> ${item}</p>`
          else return `<p>${item}</p>`
        })
        .join('')
    : ''

  // Extract column A and column B parts from text
  const columns1Regex = /CL1:\s*(.*?)(?=(CL2:)|$)/s
  const columns2Regex = /CL2:\s*(.*?)(?=(Correct Matches:)|$)/s
  const columns1Match = text.match(columns1Regex)
  const columns2Match = text.match(columns2Regex)

  // Extract correct matches part from text
  const matchesRegex = /Correct Matches:\s*(.*)/
  const matchesMatch = text.match(matchesRegex)
  const correctMatches = matchesMatch ? matchesMatch[1].trim() : ''

  // Format column A and column B as HTML list items
  const columnA = columns1Match
    ? columns1Match[1]
        .trim()
        .split('\n')
        .map((item) => `<p>${item}</p>`)
        .join('')
    : ''
  const columnB = columns2Match
    ? columns2Match[1]
        .trim()
        .split('\n')
        .map((item) => `<p>${item}</p>`)
        .join('')
    : ''

  // Format correct matches
  const correctMatchesHtml = correctMatches
    .split('|')
    .map((match) => `<span>${match}</span>`)
    .join(', ')

  return `
        ${question}
        <p><strong style="color:#ab2428;font-weight: bold;">CL1:</strong></p>
        ${columnA}
        <p><strong style="color:#ab2428;font-weight: bold;">CL2:</strong></p>
        ${columnB}
        <p><strong style="color:red;font-weight: bold;">Correct Matches:</strong> <span style="color:#ab2428;font-weight: bold;">${correctMatchesHtml}</span></p>
    `
}

export const readingText2Html = (text: string) => {
  const passageRegex = /Q(\d+)\.(.+?)(?=Q\d+\.\d+)/s
  const passageMatch = text.match(passageRegex)
  const passageIndex = passageMatch ? passageMatch[1] : ''
  const passage = passageMatch
    ? passageMatch[2]
        .trim()
        .split('\n')
        .map((item, index) => {
          if (index === 0)
            return `<p><strong style="color:blue;font-weight: bold;">Q${passageIndex}.</strong> ${item}</p>`
          else return `<p>${item}</p>`
        })
        .join('')
    : ''

  const questionsRegex = /Q((\d+)\.\d+)\.(.*?)(?=Q\d+\.\d+|$)/gs
  const questions = []
  let questionMatch
  while ((questionMatch = questionsRegex.exec(text)) !== null) {
    const question = questionMatch[0].trim()
    const questionRegex = /Q(\d+)\.(\d+)\.(.*?\n(?:.*\n)*?)(?=A\.)/s
    const questionMatch2 = question.match(questionRegex)
    const index2 = questionMatch[1]
    const questionContent = questionMatch2
      ? questionMatch2[3]
          .trim()
          .split('\n')
          .map((item, index) => {
            if (index === 0)
              return `<p class="passage_q"><strong style="color:#ab2428;font-weight: bold;">Q${index2}.</strong> ${item}</p>`
            else return `<p class="passage_q">${item}</p>`
          })
          .join('')
      : ''
    const answersRegex = /(\*?)([A-Z])\.\s(.+)/g
    const answers = []
    let answerMatch
    while ((answerMatch = answersRegex.exec(questionMatch[0])) !== null) {
      const answer = `<p class="passage_q"><strong style="color:#ff0000;font-weight: bold;">${answerMatch[1] ? '*' : ''}${answerMatch[2]}.</strong> ${answerMatch[3]}</p>`
      answers.push(answer)
    }
    questions.push(`
            ${questionContent}
            ${answers.join('')}
        `)
  }

  return `
        ${passage}
        <p><br></p>
        ${questions.join('')}
    `
}

export const writingText2Html = (text: string) => {
  const questionRegex = /Q(\d+)\.(.*)/s
  const questionMatch = text.match(questionRegex)
  const index2 = questionMatch ? questionMatch[1] : ''
  const question = questionMatch
    ? questionMatch[2]
        .trim()
        .split('\n')
        .map((item, index) => {
          if (index === 0) return `<p><strong style="color:blue;font-weight: bold;">Q${index2}.</strong> ${item}</p>`
          else return `<p>${item}</p>`
        })
        .join('')
    : ''

  return `
        ${question}
    `
}

export const div2GeoMarkdown = (text: string) => {
  const singleChoiceRegex = /\[SINGLE CHOICE\]\n(.*?)(?=(\[(MULTIPLE CHOICE|FILL BLANK|MATCHING|READING|WRITING)\])|$)/s
  const multipleChoiceRegex =
    /\[MULTIPLE CHOICE\]\n(.*?)(?=(\[(SINGLE CHOICE|FILL BLANK|MATCHING|READING|WRITING)\])|$)/s
  const fillBlankRegex = /\[FILL BLANK\]\n(.*?)(?=(\[(SINGLE CHOICE|MULTIPLE CHOICE|MATCHING|READING|WRITING)\])|$)/s
  const matchingRegex = /\[MATCHING\]\n(.*?)(?=(\[(SINGLE CHOICE|MULTIPLE CHOICE|FILL BLANK|READING|WRITING)\])|$)/s
  const readingRegex = /\[READING\]\n(.*?)(?=(\[(SINGLE CHOICE|MULTIPLE CHOICE|FILL BLANK|MATCHING|WRITING)\])|$)/s
  const writingRegex = /\[WRITING\]\n(.*?)(?=(\[(SINGLE CHOICE|MULTIPLE CHOICE|FILL BLANK|MATCHING|READING)\])|$)/s

  const singleChoiceMatch = text.match(singleChoiceRegex)
  const multipleChoiceMatch = text.match(multipleChoiceRegex)
  const fillBlankMatch = text.match(fillBlankRegex)
  const matchingMatch = text.match(matchingRegex)
  const readingMatch = text.match(readingRegex)
  const writingMatch = text.match(writingRegex)

  const singleChoice = singleChoiceMatch ? singleChoiceMatch[1].trim() : ''
  const multipleChoice = multipleChoiceMatch ? multipleChoiceMatch[1].trim() : ''
  const fillBlank = fillBlankMatch ? fillBlankMatch[1].trim() : ''
  const matching = matchingMatch ? matchingMatch[1].trim() : ''
  const reading = readingMatch ? readingMatch[1].trim() : ''
  const writing = writingMatch ? writingMatch[1].trim() : ''

  return {
    singleChoice,
    multipleChoice,
    fillBlank,
    matching,
    reading,
    writing,
  }
}

export const SingleChoiceGeoMarkdown2Objects = (text: string) => {
  const questions: Question[] = []
  const singleChoiceRegex = /Q(\d+)\.(.*?)(?=Q\d+\.|$)/gs
  const matches = text.matchAll(singleChoiceRegex)
  for (const match of matches) {
    const questionRegex = /Q(\d+)\.(.*?\n(?:.*\n)*?)(?=A\.|\*A\.)/
    const answerRegex = /(\*?)([A-Z])\.\s(.+)/g
    const questionMatch = match[0].match(questionRegex)
    if (!questionMatch) {
      continue
    }
    const question = questionMatch[2]
    const answers: Answer[] = []
    let answerMatch
    while ((answerMatch = answerRegex.exec(match[0])) !== null) {
      const isCorrect = answerMatch[1] ? true : false
      const content = answerMatch[3]
      const answer = { id: '', content, questionId: '', isCorrect }
      answers.push(answer)
    }

    // only one first answer is correct, else set to false
    let firstCorrect = true
    for (let i = 0; i < answers.length; i++) {
      if (answers[i].isCorrect && firstCorrect) {
        firstCorrect = false
      } else {
        answers[i].isCorrect = false
      }
    }

    const q: Question = {
      content: question,
      answers,
      questionType: QuestionType.SingleChoice,
      index: parseInt(questionMatch[1]),
    }
    questions.push(q)
  }
  return questions
}

export const MultipleChoiceGeoMarkdown2Objects = (text: string) => {
  const questions: Question[] = []
  const multipleChoiceRegex = /Q(\d+)\.(.*?)(?=Q\d+\.|$)/gs
  const matches = text.matchAll(multipleChoiceRegex)
  for (const match of matches) {
    const questionRegex = /Q(\d+)\.(.*?\n(?:.*\n)*?)(?=A\.|\*A\.)/
    const answerRegex = /(\*?)([A-Z])\.\s(.+)/g
    const questionMatch = match[0].match(questionRegex)
    if (!questionMatch) {
      continue
    }
    const question = questionMatch[2]
    const answers: Answer[] = []
    let answerMatch
    while ((answerMatch = answerRegex.exec(match[0])) !== null) {
      const isCorrect = answerMatch[1] ? true : false
      const content = answerMatch[3]
      const answer = { id: '', content, questionId: '', isCorrect }
      answers.push(answer)
    }
    const q: Question = {
      content: question,
      answers,
      questionType: QuestionType.MultipleChoice,
      index: parseInt(questionMatch[1]),
    }
    questions.push(q)
  }
  return questions
}

export const FillBlankGeoMarkdown2Objects = (text: string) => {
  const questions: Question[] = []
  const fillBlankRegex = /Q(\d+)\.(.*?)(?=Q\d+\.|$)/gs
  const matches = text.matchAll(fillBlankRegex)
  for (const match of matches) {
    const questionRegex = /Q(\d+)\.(.*?\n(?:.*\n)*?)(?=\d\..*\n)/s
    const answerRegex = /(\d+)\.\s(.+)/g
    const questionMatch = match[0].match(questionRegex)
    if (!questionMatch) {
      continue
    }
    let answersStr = match[0]
    answersStr = answersStr.replace(questionRegex, '')
    let question = questionMatch[2]
    const answers: Answer[] = []
    let answerMatch
    while ((answerMatch = answerRegex.exec(answersStr)) !== null) {
      const content = answerMatch[2]
      const answer = { id: '', content, questionId: '', isCorrect: true }
      answers.push(answer)
    }
    for (let i = 0; i < answers.length; i++) {
      answers[i].content = `$_[${i + 1}]${answers[i].content}`
    }

    question = question.replace(/\$\[(\d+)\]/g, '$_fillblank[$1]')

    const q: Question = {
      content: question,
      answers,
      questionType: QuestionType.FillBlank,
      index: parseInt(questionMatch[1]),
    }

    questions.push(q)
  }
  return questions
}

export const MatchingGeoMarkdown2Objects = (text: string) => {
  const questions: Question[] = []
  const matchingRegex = /Q(\d+)\.(.*?)(?=Q\d+\.|$)/gs
  const matches = text.matchAll(matchingRegex)
  for (const match of matches) {
    const questionRegex = /Q(\d+)\.(.*?\n(?:.*\n)*?)(?=Correct Matches:)/s
    const questionMatch = match[0].match(questionRegex)
    if (!questionMatch) {
      continue
    }
    const questionContentRegex = /Q(\d+)\.(.*?\n(?:.*\n)*?)(?=CL1:|$)/s
    const questionContentMatch = match[0].match(questionContentRegex)

    const question = questionMatch[2]
    const answers: Answer[] = []
    const columns1Regex = /CL1:\s*(.*?)(?=(CL2:)|$)/s
    const columns2Regex = /CL2:\s*(.*?)(?=(Correct Matches:)|$)/s
    const columns1Match = question.match(columns1Regex)
    const columns2Match = question.match(columns2Regex)

    const column1 = columns1Match ? columns1Match[1].trim() : ''
    const column2 = columns2Match ? columns2Match[1].trim() : ''

    const correctMatchesRegex = /Correct Matches:\s*(.*)/
    const correctMatchesMatch = text.match(correctMatchesRegex)
    let correctMatches = correctMatchesMatch ? correctMatchesMatch[1].trim() : ''
    const correctMatchesArr = correctMatches.split(',')
    for (let i = 0; i < correctMatchesArr.length; i++) {
      correctMatchesArr[i] = correctMatchesArr[i].trim()
    }
    correctMatches = correctMatchesArr.join('|')

    const column1Items = column1.split('\n')
    const column2Items = column2.split('\n')

    answers.push({ id: '', content: correctMatches, questionId: '', isCorrect: true })

    const columnA: Record<string, string> = {}
    for (let i = 0; i < column1Items.length; i++) {
      const regex = /(\d+)\.\s(.+)/
      const match = column1Items[i].match(regex)
      if (match) {
        columnA[match[1]] = match[2]
      }
    }

    const columnB: Record<string, string> = {}
    for (let i = 0; i < column2Items.length; i++) {
      // regex to extract number and text
      const regex = /(\d+)\.\s(.+)/
      const match = column2Items[i].match(regex)
      if (match) {
        columnB[match[1]] = match[2]
      }
    }

    const content = {
      Question: questionContentMatch ? questionContentMatch[2] || '' : '',
      ColumnA: columnA,
      ColumnB: columnB,
    }

    const q: Question = {
      content: JSON.stringify(content),
      answers,
      questionType: QuestionType.Matching,
      index: parseInt(questionMatch[1]),
    }

    questions.push(q)
  }
  return questions
}

export const ReadingGeoMarkdown2Objects = (text: string) => {
  const questions: Question[] = []
  const readingRegex = /Q(\d+)\.(.*?)(?=Q\d+\.\s|$)/gs
  const matches = text.matchAll(readingRegex)
  for (const match of matches) {
    const questionRegex = /Q(\d+)\.(.*?)(?=(Q\d+\.\d+\.)|$)/s
    const questionMatch = match[0].match(questionRegex)

    if (!questionMatch) {
      continue
    }

    const passage = questionMatch[2].trim()

    const questionPassages: any[] = []

    const passageQuestionsRegex = /Q(\d+)\.(\d+)\.(.*?)(?=(Q\d+\.\d+\.)|$)/gs
    let passageQuestionMatch

    while ((passageQuestionMatch = passageQuestionsRegex.exec(match[0])) !== null) {
      const questionContentRegex = /Q(\d+)\.(\d+)\.(.*?\n(?:.*\n)*?)(?=A\.)/s
      const questionContentMatch = passageQuestionMatch[0].match(questionContentRegex)
      const question = questionContentMatch ? questionContentMatch[3].trim() : ''

      const answersRegex = /(\*?)([A-Z])\.\s(.+)/g
      const answers: Answer[] = []
      let answerMatch
      while ((answerMatch = answersRegex.exec(passageQuestionMatch[0])) !== null) {
        const isCorrect = answerMatch[1] ? true : false
        const content = answerMatch[3]
        const answer = { id: '', content, questionId: '', isCorrect }
        answers.push(answer)
      }

      const q: any = {
        content: question,
        answers,
        questionType: QuestionType.SingleChoice,
        index: parseInt(passageQuestionMatch[2]),
      }

      questionPassages.push(q)
    }

    const q: Question = {
      content: passage,
      questionPassages,
      questionType: QuestionType.Reading,
      index: parseInt(questionMatch[1]),
      answers: [],
    }

    questions.push(q)
  }

  return questions
}

export const WritingGeoMarkdown2Objects = (text: string) => {
  const questions: Question[] = []
  const writingRegex = /Q(\d+)\.(.*?)(?=Q\d+\.\s|$)/gs
  const matches = text.matchAll(writingRegex)
  for (const match of matches) {
    const questionRegex = /Q(\d+)\.(.*)/s
    const questionMatch = match[0].match(questionRegex)
    if (!questionMatch) {
      continue
    }
    const question = questionMatch[2].trim()
    const q: Question = {
      content: question,
      answers: [],
      questionType: QuestionType.Writing,
      index: parseInt(questionMatch[1]),
    }
    questions.push(q)
  }
  return questions
}

export const GeoMarkdown2Objects = (text: string) => {
  const { singleChoice, multipleChoice, fillBlank, matching, reading, writing } = div2GeoMarkdown(text)
  const questions: Question[] = []

  // Single Choice
  const singleChoiceQuestions = SingleChoiceGeoMarkdown2Objects(singleChoice)
  questions.push(...singleChoiceQuestions)

  // Multiple Choice
  const multipleChoiceQuestions = MultipleChoiceGeoMarkdown2Objects(multipleChoice)
  questions.push(...multipleChoiceQuestions)

  // Fill Blank
  const fillBlankQuestions = FillBlankGeoMarkdown2Objects(fillBlank)
  questions.push(...fillBlankQuestions)

  // Matching
  const matchingQuestions = MatchingGeoMarkdown2Objects(matching)
  questions.push(...matchingQuestions)

  // Reading
  const readingQuestions = ReadingGeoMarkdown2Objects(reading)
  questions.push(...readingQuestions)

  // Writing
  const writingQuestions = WritingGeoMarkdown2Objects(writing)
  questions.push(...writingQuestions)

  return questions
}
